ASIG Fuzzilli Documentation
==========================


This document aims to providue guidance in ASIG javascript-engine fuzzing campaigns that choose to utilize the [Fuzzilli Fuzzer](https://github.com/googleprojectzero/fuzzilli)

### Fuzzilli
TLDR; Fuzzilli is a coverage-guided fuzzer for dynamic language interpreters based on a custom intermediate language ("FuzzIL") which can be mutated and translated to JavaScript.

For a more involved discussion on FuzzIL and how javascript is generated by fuzzilli, see [Saelo's Master Thesis](https://saelo.github.io/papers/thesis.pdf)

### Methodology Breakdown
1. Patch the javascript engine shell to communicate with and evaluate scripts on behalf of the fuzzzer
2. Recompile the engine with full debug info and an llvm code coverage sanitizer
3. Expose a function that consistently segfaults to the fuzzer so it can correctly identify crashes
4. Create a FuzzilliCli profile for the target
2. Deploy the fuzzer
3. Triage Crashes
4. Pwn..?


### Patching the engine
The first thing we want to do is enable communication between fuzzilli and our target engine. 

The communication we implement will take place via a REPRL loop. As a derivitave of the perhaps more familiar Read-Eval-Print-Loop, the Read-Eval-Print-Loop-Reset communication we will implement includes an extra step where the state of the execution engine is reset after each execution. 

Using well known file descriptors to communicate between the parent (fuzzilli) and child process (target engine), the implementation will allow for the following communication scheme:

child: writes 'HELO' to the CWFD to notify fuzzilli its ready for input
parent: reads child's 'HELO' and writes 'HELO' to CRFD
loop until signal interrupt:
    parent: writes command to CRFD
    child: reads command from CRFD
    if command == 'cexe':
        parent: writes size of generated javascript to CRFD
        child: reads size of generated javascript from CRFD
        parent: writes generated javascript to CRFD
        child: reads script from DRFD, executes, writes return codes to CWFD, and resets state

In between this communication, there are a few points of interest that might benefit from a bit of clarification:

You must append a null terminator to the read in javascript.
```
script_src[script_size] = '\0';
```

You must remember to call `__sanitizer_cov_reset_edgeguards` after writing the status.


Now that you have an understanding of the functionality we are trying to enable, you're probably wondering where it should be implemented.




### Recompiling the engine

### Exposing a function that consistently segfaults

### Creating a profile

##### (Optional) Adding a JIT Generator


#### Installing Swift

`$ wget https://download.swift.org/swift-5.6.1-release/ubuntu2004/swift-5.6.1-RELEASE/swift-5.6.1-RELEASE-ubuntu20.04.tar.gz`
`$ tar -xvf swift-*-RELEASE-ubuntu20.04.tar.gz`

### Deploying the Fuzzer
Fuzzilli can be run as follows: 
```
swift run FuzzilliCli --storagePath=results/ --profile=qtjs ../QJSEngine-Fuzzili-Wrapper/instrumentation
```
where storagePath is the folder where results of fuzzing are stored. The last argument is the path to the reprl

### Triaging crashes



### Pwn..?

It is helpful to demangle c++ names in GDB can be added to your `~/.gdbinit`
```
set print asm-demangle on
```
