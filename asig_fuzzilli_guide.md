ASIG Fuzzilli Documentation
==========================


This document aims to providue guidance in ASIG javascript-engine fuzzing campaigns that choose to utilize the [Fuzzilli Fuzzer](https://github.com/googleprojectzero/fuzzilli). A more succinct version of instructions can be found within the [repository](https://github.com/googleprojectzero/fuzzilli/blob/main/Targets/README.md). Our intent is to expand on these instructions to give more detailed guidance based upon our experience using this fuzzer. 


### Fuzzilli
Fuzzilli is a coverage-guided fuzzer for javascript engines based on a custom intermediate language ("FuzzIL") which can be mutated and translated to JavaScript.

For a more involved discussion on FuzzIL and how javascript is generated by fuzzilli, see [How Fuzzilli Works](https://github.com/googleprojectzero/fuzzilli/blob/main/Docs/HowFuzzilliWorks.md)


### Methodology Breakdown
1. Patching The Engine
2. Enabling Crash Identification
3. Recompiling The Engine
4. Creating A Fuzzilli Profile
5. Fuzzer Deployment
6. Post-Deployment


### Patching The Engine
The first thing we want to do is enable communication between fuzzilli and our target engine. 

The communication we implement will take place via a REPRL loop. As a derivitave of the perhaps more familiar Read-Eval-Print-Loop, the Read-Eval-Print-Loop-Reset communication we will implement includes an extra step where the state of the execution engine is reset after each execution.

Before communication begins, the following items will need to be completed:
- declare the `__sanitize_cov_reset_edgeguards();` function
- initialize the engine
- make the intentional segfault function available to fuzzilli (more on this in the next section)
- check for a '-reprl' command line option, if present, then begin communication

Using well known file descriptors to communicate between the parent (fuzzilli) and child process (target engine) found in [coverage.c](https://github.com/googleprojectzero/fuzzilli/blob/main/Targets/coverage.c), the implementation will allow for the following communication scheme:

child: writes 'HELO' to the CWFD to notify fuzzilli its ready for input
fuzzilli: reads child's 'HELO' and writes 'HELO' to CRFD
loop until signal interrupt:
    fuzzilli: writes command to CRFD
    child: reads command from CRFD
    if command == 'cexe':
        fuzzilli: writes size of generated javascript to CRFD
        child: reads size of generated javascript from CRFD
        fuzzilli: writes generated javascript to CRFD
        child: reads script from DRFD, executes, writes return codes to CWFD, and resets state

Notes:
- You must append a null terminator to the script after its read from the CRFD `script_src[script_size] = '\0';`
- Before returning the status code, a bitwise & and a bitshift to the right by 8 bits should be applied to it `status = (status & 0XFF) << 8;`
- You must remember to call `__sanitizer_cov_reset_edgeguards` after writing the status as part of the reset stage

All implementations are patches to either the main source file of the engine or a source file that compiles into an executable shell. Instead of patching pre-existing files, it is also possible to create a new file for the instrumentation if the engine is imported into the file. 


### Enabling Crash Identification
In order for fuzzilli to correctly identify segmentation faults, we need to provide it with a function that will consistently segfault. You'll need to complete the following steps:

1. write a function in the implementation language of the engine that performs some illegal memory access 
2. make the function callable from javascript
3. set the function as a property of the global object

Notes:
- an illegal memory access can be something as simple as the following line in the engine implementation language
```
*((int *)0x41414141) = 0x1337; 
```
- You'll need to look around the engine implementation to find out how to make a function written in the engine implementation language accessible to the javascript. In our implementation we needed to make a modification of the object to inherit from QObject and expose a Q_INVOKABLE interface 
- make sure to perform this inside the reprl loop since the engine is destroyed and re-initialized each iteration

Once you have implemented this function and exposed it to the engine, its time to test the reprl implementation. You can do so with the following command. Make sure to grab a [swift binary](https://www.swift.org/download/) to run fuzzilli.
```
swift run REPRLRun <path/to/instrumentation> -reprl
```


### Engine Recompilation
After you've patched the engine, the next step is making sure we enabled the sanitizer that we defined and compile with full debug so as to have access to the source and symbol table

With clang, the following flags should be added onto the make command for the engine
- `-g`
- `-fsanitize-coverage=trace-pc-guard`

Gcc is not supported by fuzzilli since it doesn't call `__sanitizer_cov_trace_pc_guard_init`

### Profile Creation
In order for fuzzilli to know how to interact with this specific target, a profile file must be created. Using the existing [profiles](https://github.com/googleprojectzero/fuzzilli/tree/main/Sources/FuzzilliCli/Profiles) as examples, you must: 
1. define the variables declared in [Profile.swift](https://github.com/googleprojectzero/fuzzilli/blob/main/Sources/FuzzilliCli/Profiles/Profile.swift) with values specific to your target engine
2. add the name of your profile to the `profiles` list in [Profile.swift](https://github.com/googleprojectzero/fuzzilli/blob/main/Sources/FuzzilliCli/Profiles/Profile.swift)

You can find an overview of the fields [here](https://github.com/googleprojectzero/fuzzilli/tree/main/Targets#profile-fields)

Notes:
- `crashTests`: intentional segfault function we wrote earlier
- `disabledCodeGenerators`: if your engine doesn't support a functionality enabled by a certain generator (see all generators [here](https://github.com/googleprojectzero/fuzzilli/blob/main/Sources/FuzzilliCli/CodeGeneratorWeights.swift)), you can disable it by listing the generator name here
- `additionalCodeGenerators`: this is where you'll want to implement a JIT generator, see the [V8 profile](https://github.com/googleprojectzero/fuzzilli/blob/main/Sources/FuzzilliCli/Profiles/V8Profile.swift) for an example implementation


### Fuzzer Deployment
Fuzzilli can be run as follows from within the root directory
```
swift run FuzzilliCli --storagePath=<path/to/results> --profile=<name of profile> <path/to/instrumentation>
```

Since you're likely deploying this on an ASIG fuzzing vm with multiple cores, you'll want to consider using the `--jobs` flag to specify the number of child fuzzing processes.

It is advisable to setup a script that watches the fuzzilli process and restarts it when it dies. In our experience, it was not uncommon for fuzzilli to fail due to an IOT illegal instruction invocation


### Post-Deployment
Once the fuzzer is up and running, you should begin to see the javascript responsible for generating each crash being placed into a file within the ./crashes subdir of the directory passed into the `--storagePath` flag. The file names of the crash generating javascript samples take the form `program_<datetime>_<uuid>_<deterministic/flaky>.js`


You might notice that after running the fuzzer for a while, crashes stemming from the same defect might begin to take up the majority of your time during manual crash triage. This can be addressed with any combination of the following solutions:

1. **Tinkering with the [Code Generator Weights](https://github.com/googleprojectzero/fuzzilli/blob/main/Sources/FuzzilliCli/CodeGeneratorWeights.swift)**. Fuzzilli uses code generators to bias the mutational fuzzer towards the use of certain programming constructs over others. If you're receiving a lot of duplicate crashes, changing the generator weights can allow for higher coverage and less duplicates.
2. **Utilizing an automated crash-triage program**. [Crashwalk](https://github.com/bnagy/crashwalk) is an example of a script that can be run on a directory of crashes to save time for researchers and group them into the following categories; EXPLOITABLE, PROBABLY_EXPLOITABLE, PROBABLY_NOT_EXPLOITABLE, NOT_EXPLOITABLE, UNKNOWN, based on the contents of the stack at crash time. Crashwalk uses the [exploitable gdb plugin](https://github.com/jfoote/exploitable) and can identify duplicates and augment the way we prioritize crashes to analyze manually during the triage process.
3. **Using custom crash duplicate detection heuristics**. If you've already written a script to watch and restart fuzzilli and automatically run crashwalk on the crashes, a great next step to minimize the amount of duplicates that show up in your terminal for manual analysis is to implement code to parse the output of `crashwalk triage` and begin pruning crashes based on certain heuristics that can be observed in the contents of the stack. An example of this would be a threshold amount of recursive calls between two functions which you already know crash due to an uncontrolled recursion defect. Its important to note that in order for this component to be effective, it should be easily extensible and new heuristics should be added as soon as duplicate crash generation exceeds expected levels.


We hope this was helpful to you and that you find many bugs on your javascript fuzzing journey :-)

