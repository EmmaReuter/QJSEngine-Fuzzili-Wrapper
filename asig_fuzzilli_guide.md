ASIG Fuzzilli Documentation
==========================


This document aims to providue guidance in ASIG javascript-engine fuzzing campaigns that choose to utilize the [Fuzzilli Fuzzer](https://github.com/googleprojectzero/fuzzilli). A more succinct version of instructions can be found within the (repository)[https://github.com/googleprojectzero/fuzzilli/blob/main/Targets/README.md]. Our intent is to expand on these instructions to give more detailed guidance based upon our experience using this fuzzer. 

### Fuzzilli
Summary: Fuzzilli is a coverage-guided fuzzer for javascript engines based on a custom intermediate language ("FuzzIL") which can be mutated and translated to JavaScript.

For a more involved discussion on FuzzIL and how javascript is generated by fuzzilli, see [How Fuzzilli Works](https://github.com/googleprojectzero/fuzzilli/blob/main/Docs/HowFuzzilliWorks.md)

### Methodology Breakdown
1. Patch the javascript engine shell to communicate with and evaluate scripts on behalf of the fuzzzer
2. Recompile the engine with full debug info and an llvm code coverage sanitizer
3. Expose a function that consistently segfaults to the fuzzer so it can correctly identify crashes
4. Create a FuzzilliCli profile for the target
2. Deploy the fuzzer
3. Triage Crashes
4. Pwn..?


### Patching the engine
The first thing we want to do is enable communication between fuzzilli and our target engine. 

The communication we implement will take place via a REPRL loop. As a derivitave of the perhaps more familiar Read-Eval-Print-Loop, the Read-Eval-Print-Loop-Reset communication we will implement includes an extra step where the state of the execution engine is reset after each execution. 

Using well known file descriptors to communicate between the parent (fuzzilli) and child process (target engine), the implementation will allow for the following communication scheme:

child: writes 'HELO' to the CWFD to notify fuzzilli its ready for input
parent: reads child's 'HELO' and writes 'HELO' to CRFD
loop until signal interrupt:
    parent: writes command to CRFD
    child: reads command from CRFD
    if command == 'cexe':
        parent: writes size of generated javascript to CRFD
        child: reads size of generated javascript from CRFD
        parent: writes generated javascript to CRFD
        child: reads script from DRFD, executes, writes return codes to CWFD, and resets state

In between this communication, there are a few points of interest that might benefit from a bit of clarification:

- You must append a null terminator to the script after its read from the DRFD
- Before returning the status code, a bitwise & and a bitshift to the right by 8 bits should be applied to it 
- You must remember to call `__sanitizer_cov_reset_edgeguards` after writing the status as part of the reset stage

Now that you have an understanding of the functionality we are trying to enable, you're probably wondering where it should be implemented.

At the time of writing, all implementations are patches to either the main source file of the engine or a source file that compiles into an executable shell. Instead of patching pre-existing files, it is also possible to import the engine into a blank 

### Testing the Reprl
To test the reprl implementation you can use the Reprl tester:
```
swift run REPRLRun ../QJSEngine-Fuzzili-Wrapper/instrumentation -reprl
```
The arguments for REPRLRun is the path to the jshell and then any additional arguments.

### Recompiling the engine

### Exposing a function that consistently segfaults

### Creating a profile

##### (Optional) Adding a JIT Generator


#### Installing Swift

`$ wget https://download.swift.org/swift-5.6.1-release/ubuntu2004/swift-5.6.1-RELEASE/swift-5.6.1-RELEASE-ubuntu20.04.tar.gz`
`$ tar -xvf swift-*-RELEASE-ubuntu20.04.tar.gz`

### Deploying the Fuzzer

Fuzzilli can be run as follows: 
```
swift run FuzzilliCli --storagePath=results/ --profile=qtjs ../QJSEngine-Fuzzili-Wrapper/instrumentation
```
where storagePath is the folder where results of fuzzing are stored. The last argument is the path to the reprl

### Triaging crashes



### Pwn..?

To demangle c++ names in GDB:
```
set print asm-demangle on
```
can also be added to your `~/.gdbinit`
