ASIG Fuzzilli Documentation
==========================


This document aims to providue guidance in ASIG javascript-engine fuzzing campaigns that choose to utilize the [Fuzzilli Fuzzer](https://github.com/googleprojectzero/fuzzilli)

### Fuzzilli
TLDR; Fuzzilli is a coverage-guided fuzzer for dynamic language interpreters based on a custom intermediate language ("FuzzIL") which can be mutated and translated to JavaScript.

For a more involved discussion on FuzzIL and how javascript is generated by fuzzilli, see [Saelo's Master Thesis](https://saelo.github.io/papers/thesis.pdf)

### Methodology Breakdown
1. Patch the javascript engine shell to communicate with and evaluate scripts on behalf of the fuzzzer
2. Recompile the engine with full debug info and an llvm code coverage sanitizer
3. Expose a function that consistently segfaults to the fuzzer so it can correctly identify crashes
4. Create a FuzzilliCli profile for the target
2. Deploy the fuzzer
3. Triage Crashes
4. Pwn..?


### Patching the engine
The first thing we want to do is enable communication between fuzzilli and our target engine. 

The communication we implement will take place via a REPRL loop. As a derivitave of the perhaps more familiar Read-Eval-Print-Loop, the Read-Eval-Print-Loop-Reset communication we will implement includes an extra step where the state of the execution engine is reset after each execution. 

Using well known file descriptors to communicate between the parent (fuzzilli) and child process (target engine), the implementation will allow for the following communication scheme:

child: writes 'HELO' to the CWFD to notify fuzzilli its ready for input
parent: reads child's 'HELO' and writes 'HELO' to CRFD
loop until signal interrupt:
    parent: writes command to CRFD
    child: reads command from CRFD
    if command == 'cexe':
        parent: writes size of generated javascript to CRFD
        child: reads size of generated javascript from CRFD
        parent: writes generated javascript to CRFD
        child: reads script from DRFD, executes, writes return codes to CWFD, and resets state

In between this communication, there are a few points of interest that might benefit from a bit of clarification:
- 


Now that you have an understanding of the functionality we are trying to enable, you're probably wondering where it should be implemented.



Follow the REPRL [pseudocode](https://github.com/googleprojectzero/fuzzilli/tree/main/Targets).

### Recompiling the engine

### Exposing a function that consistently segfaults

### Creating a profile

##### (Optional) Adding a JIT Generator

### Deploying the fuzzer

#### Installing Swift

`$ wget https://download.swift.org/swift-5.6.1-release/ubuntu2004/swift-5.6.1-RELEASE/swift-5.6.1-RELEASE-ubuntu20.04.tar.gz`
`$ tar -xvf swift-*-RELEASE-ubuntu20.04.tar.gz`

### Deploying the Fuzzer
`$ ./swift-5.6.1-RELEASE-ubuntu20.04/usr/bin/swift build -c debug`

`$ ../swift-5.6.1-RELEASE-ubuntu20.04/usr/bin/swift run -c debug FuzzilliCli ---storagePath=../results -profile=qtjs  /path/to/jsshell`

### Triaging crashes

### Pwn..?
