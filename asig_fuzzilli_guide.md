ASIG Fuzzilli Documentation
==========================


This document aims to providue guidance in ASIG javascript-engine fuzzing campaigns that choose to utilize the [Fuzzilli Fuzzer](https://github.com/googleprojectzero/fuzzilli). A more succinct version of instructions can be found within the (repository)[https://github.com/googleprojectzero/fuzzilli/blob/main/Targets/README.md]. Our intent is to expand on these instructions to give more detailed guidance based upon our experience using this fuzzer. 

### Fuzzilli
Summary: Fuzzilli is a coverage-guided fuzzer for javascript engines based on a custom intermediate language ("FuzzIL") which can be mutated and translated to JavaScript.

For a more involved discussion on FuzzIL and how javascript is generated by fuzzilli, see [How Fuzzilli Works](https://github.com/googleprojectzero/fuzzilli/blob/main/Docs/HowFuzzilliWorks.md)

### Methodology Breakdown
1. Patch the javascript engine shell to communicate with and evaluate scripts on behalf of the fuzzzer
2. Recompile the engine with full debug info and an llvm code coverage sanitizer
3. Expose a function that consistently segfaults to the fuzzer so it can correctly identify crashes
4. Create a FuzzilliCli profile for the target
2. Deploy the fuzzer
3. Triage Crashes
4. Pwn..?


### Patching the engine
The first thing we want to do is enable communication between fuzzilli and our target engine. 

The communication we implement will take place via a REPRL loop. As a derivitave of the perhaps more familiar Read-Eval-Print-Loop, the Read-Eval-Print-Loop-Reset communication we will implement includes an extra step where the state of the execution engine is reset after each execution to reduce overhead when executing new test cases.

Before communication begins, the following items will need to be completed:
- declare the `__sanitize_cov_reset_edgeguards();` function
- initialize the engine
- make the intentional segfault function available to fuzzilli (more on this in the next section)
- check for a '-reprl' command line option, if present, then begin communication

Using well known file descriptors to communicate between the parent (fuzzilli) and child process (target engine), the implementation will allow for the following communication scheme:

child: writes 'HELO' to the CWFD to notify fuzzilli its ready for input
parent: reads child's 'HELO' and writes 'HELO' to CRFD
loop until signal interrupt:
    parent: writes command to CRFD
    child: reads command from CRFD
    if command == 'cexe':
        parent: writes size of generated javascript to CRFD
        child: reads size of generated javascript from CRFD
        parent: writes generated javascript to CRFD
        child: reads script from DRFD, executes, writes return codes to CWFD, and resets state

Notes:
- You must append a null terminator to the script after its read from the DRFD
- Before returning the status code, a bitwise & and a bitshift to the right by 8 bits should be applied to it 
- You must remember to call `__sanitizer_cov_reset_edgeguards` after writing the status as part of the reset stage

Now that you have an understanding of the functionality we are trying to enable, you're probably wondering where it should be implemented.

At the time of writing, all implementations are patches to either the main source file of the engine or a source file that compiles into an executable shell. Instead of patching pre-existing files, it is also possible to create a new file for the instrumentation if the engine is imported into the file. 

### Exposing a function that consistently segfaults

In order for fuzzilli to correctly identify segmentation faults, we need to provide it with a function that will consistently segfault. You'll need to complete the following steps:

1. write a function in the implementation language of the engine that performs some illegal memory access 
2. make the function callable from javascript
3. set the function as a property of the global object


Notes:
- an illegal memory access can be something as simple as the following line in the engine implementation language
```
*((int *)0x41414141) = 0x1337; 
```
- You'll need to look around the engine implementation to find out how to make a function written in the engine implementation language accessible to the javascript. In our implementation we needed to make a modification of the object to inherit from QObject and expose a Q_INVOKABLE interface 
- make sure to perform this inside the reprl loop since the engine is destroyed and re-initialized each iteration

Once you have implemented this function and exposed it to the engine, its time to test the reprl implementation. You can do so with the following command. Make sure to grab a [swift binary](https://www.swift.org/download/) to run fuzzilli.
```
swift run REPRLRun <path/to/instrumentation> -reprl
```

### Recompiling the engine

After you've patched the engine, the next step is making sure we enabled the sanitizer that we defined and compile with full debug so as to have access to the source and symbol table

With clang, the following flags should be added onto the make command for the engine
- `-g`
- `-fsanitize-coverage=trace-pc-guard

### Creating a profile

In order for fuzzilli to know how to interact with this specific target, a profile file must be created. Using the existing [profiles](https://github.com/googleprojectzero/fuzzilli/tree/main/Sources/FuzzilliCli/Profiles) as examples, you must: 
1. define the variables declared in [Profile.swift](https://github.com/googleprojectzero/fuzzilli/blob/main/Sources/FuzzilliCli/Profiles/Profile.swift) with values specific to your target engine
2. add the name of your profile to the `profiles` list in [Profile.swift](https://github.com/googleprojectzero/fuzzilli/blob/main/Sources/FuzzilliCli/Profiles/Profile.swift)

You can find an overview of the fields [here](https://github.com/googleprojectzero/fuzzilli/tree/main/Targets#profile-fields)

Notes:
- `crashTests`: intentional segfault function we wrote earlier
- `disabledCodeGenerators`: if your engine doesn't support a functionality enabled by a certain generator (see all generators [here](https://github.com/googleprojectzero/fuzzilli/blob/main/Sources/FuzzilliCli/CodeGeneratorWeights.swift)), you can disable it by listing the generator name here
- `additionalCodeGenerators`: this is where you'll want to implement a JIT generator, see the [V8 profile](https://github.com/googleprojectzero/fuzzilli/blob/main/Sources/FuzzilliCli/Profiles/V8Profile.swift) for an example implementation


### Deploying the Fuzzer

Fuzzilli can be run as follows from within the root directory
```
<path/to/swift/binary> run FuzzilliCli --storagePath=<path/to/results> --profile=<name of profile> <path/to/instrumentation>
```

Since you're likely deploying this on an ASIG fuzzing vm with multiple cores, you'll want to consider using the `--jobs` flag to specify the number of child fuzzing processes.

It is advisable to setup a script that watches the fuzzilli process and restarts it when it dies. In our experience, it was not uncommon for fuzzilli to fail due to an IOT illegal instruction invocation


### Triaging crashes

If you already have a script setup to watch and restart the fuzzilli process, a good next step is to add some automation improve effiA in the triage stage of the campaign.


### Pwn..?

To demangle c++ names in GDB:
```
set print asm-demangle on
```
can also be added to your `~/.gdbinit`
